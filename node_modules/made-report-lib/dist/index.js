// src/documentation/service/markdown/MarkdownService.ts
import * as fs9 from "fs";

// src/util/generator-utils.ts
import * as path from "path";
import * as fs from "fs";
var ident_size = 4;
var base_ident = " ".repeat(ident_size);
function createPath(...args) {
  const PATH = path.join(...args);
  if (!fs.existsSync(PATH)) {
    fs.mkdirSync(PATH, { recursive: true });
  }
  return PATH;
}

// src/documentation/service/markdown/MarkdownBacklogService.ts
import * as path3 from "path";
import * as fs5 from "fs";
import { LowSync } from "lowdb";
import { JSONFileSync } from "lowdb/node";

// src/documentation/service/markdown/chart/project/ProjectMetricsGenerator.ts
import fs4 from "fs";
import path2 from "path";

// src/documentation/service/markdown/chart/project/ProjectCFD.ts
import * as fs2 from "fs";
var ProjectCFD = class {
  sprints;
  outputPath;
  constructor(sprints, outputPath = "./project-cfd.svg") {
    this.sprints = this.sortSprints(sprints);
    this.outputPath = outputPath;
  }
  parseBrazilianDate(dateString) {
    const [day, month, year] = dateString.split("/").map(Number);
    return new Date(year, month - 1, day);
  }
  sortSprints(sprints) {
    return sprints.sort(
      (a, b) => this.parseBrazilianDate(a.startDate).getTime() - this.parseBrazilianDate(b.startDate).getTime()
    );
  }
  processData() {
    const formatDate = (date) => {
      const dia = date.getDate().toString().padStart(2, "0");
      const mes = (date.getMonth() + 1).toString().padStart(2, "0");
      return `${dia}/${mes}`;
    };
    const startDate = this.parseBrazilianDate(this.sprints[0].startDate);
    const endDate = this.parseBrazilianDate(this.sprints[this.sprints.length - 1].endDate);
    const days = [];
    let currentDate = new Date(startDate);
    while (currentDate <= endDate) {
      const weekDay = currentDate.toLocaleDateString("pt-BR", { weekday: "short" });
      const formattedDate = formatDate(currentDate);
      const allTasksUntilDay = this.sprints.flatMap((sprint) => {
        return sprint.sprintItems.filter((task) => {
          const taskStartDate = task.startDate ? this.parseBrazilianDate(task.startDate) : null;
          return taskStartDate ? taskStartDate <= currentDate : true;
        });
      });
      days.push({
        day: `${weekDay} ${formattedDate}`,
        date: new Date(currentDate),
        todo: allTasksUntilDay.filter((task) => task.status === "TODO").length,
        inProgress: allTasksUntilDay.filter(
          (task) => task.status === "IN_PROGRESS" || task.status === "DOING"
        ).length,
        done: allTasksUntilDay.filter((task) => task.status === "DONE").length
      });
      currentDate.setDate(currentDate.getDate() + 1);
    }
    return days;
  }
  generateSVG() {
    const width = 1200;
    const height = 600;
    const margin = { top: 50, right: 150, bottom: 100, left: 70 };
    const colors = {
      todo: "#ef4444",
      inProgress: "#f59e0b",
      done: "#22c55e",
      grid: "#e5e7eb",
      text: "#000000",
      lightText: "#666666"
    };
    const dailyData = this.processData();
    const totalTasks = this.sprints.reduce((sum, sprint) => sum + sprint.sprintItems.length, 0);
    if (totalTasks === 0) {
      throw new Error("N\xE3o h\xE1 tarefas para gerar o gr\xE1fico");
    }
    const chartWidth = width - margin.left - margin.right;
    const chartHeight = height - margin.top - margin.bottom;
    const xScale = (date) => {
      const startDate = this.parseBrazilianDate(this.sprints[0].startDate);
      const totalDays = Math.max(1, dailyData.length - 1);
      const dayIndex = Math.floor((date.getTime() - startDate.getTime()) / (1e3 * 60 * 60 * 24));
      return margin.left + dayIndex * (chartWidth / totalDays);
    };
    const yScale = (value) => {
      return height - margin.bottom - value * (chartHeight / Math.max(1, totalTasks));
    };
    const generateArea = (data, getValue) => {
      if (data.length === 0) return "";
      const points = data.map((d) => {
        const x = xScale(d.date);
        const y = yScale(getValue(d));
        return `${x},${y}`;
      });
      const bottomPoints = data.map((d) => {
        const x = xScale(d.date);
        return `${x},${height - margin.bottom}`;
      }).reverse();
      return `M${points.join(" L")} L${bottomPoints.join(" L")} Z`;
    };
    const svg = `
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${width} ${height}">
        <defs>
          <style>
            text { font-family: Arial, sans-serif; }
            .title { font-size: 24px; font-weight: bold; }
            .label { font-size: 14px; }
            .value { font-size: 12px; fill: ${colors.lightText}; }
            .axis { font-size: 12px; }
            .legend { font-size: 14px; }
          </style>
        </defs>

        <rect width="${width}" height="${height}" fill="white"/>

        ${Array.from({ length: 11 }, (_, i) => {
      const y = margin.top + i * (chartHeight / 10);
      return `
            <line 
              x1="${margin.left}" 
              y1="${y}" 
              x2="${width - margin.right}" 
              y2="${y}" 
              stroke="${colors.grid}" 
              stroke-dasharray="4"
            />
            <text 
              x="${margin.left - 10}" 
              y="${y}" 
              text-anchor="end" 
              class="axis" 
              dominant-baseline="middle"
            >${Math.round(totalTasks - i * (totalTasks / 10))}</text>
          `;
    }).join("")}

        <path 
          d="${generateArea(dailyData, (d) => d.todo + d.inProgress + d.done)}" 
          fill="${colors.todo}" 
          opacity="0.8"
        />
        <path 
          d="${generateArea(dailyData, (d) => d.inProgress + d.done)}" 
          fill="${colors.inProgress}" 
          opacity="0.8"
        />
        <path 
          d="${generateArea(dailyData, (d) => d.done)}" 
          fill="${colors.done}" 
          opacity="0.8"
        />

        <line 
          x1="${margin.left}" 
          y1="${margin.top}" 
          x2="${margin.left}" 
          y2="${height - margin.bottom}" 
          stroke="black" 
          stroke-width="2"
        />
        <line 
          x1="${margin.left}" 
          y1="${height - margin.bottom}" 
          x2="${width - margin.right}" 
          y2="${height - margin.bottom}" 
          stroke="black" 
          stroke-width="2"
        />

        ${dailyData.map((d, i) => {
      if (i % 2 === 0) {
        const x = xScale(d.date);
        return `
              <text 
                transform="rotate(-45 ${x} ${height - margin.bottom + 20})"
                x="${x}"
                y="${height - margin.bottom + 20}"
                text-anchor="end"
                class="axis"
              >${d.day}</text>
            `;
      }
      return "";
    }).join("")}

        <text 
          transform="rotate(-90 ${margin.left - 40} ${height / 2})" 
          x="${margin.left - 40}" 
          y="${height / 2}" 
          text-anchor="middle" 
          class="label"
        >N\xFAmero de Tarefas</text>

        <text 
          x="${width / 2}" 
          y="${height - 20}" 
          text-anchor="middle" 
          class="label"
        >Per\xEDodo do Projeto</text>

        <text 
          x="${width / 2}" 
          y="30" 
          text-anchor="middle" 
          class="title"
        >Cumulative Flow Diagram - Projeto Completo</text>

        <g transform="translate(${width - margin.right + 20}, ${margin.top})">
          <rect width="15" height="15" fill="${colors.todo}" rx="2"/>
          <text x="25" y="12" class="legend">TODO</text>
          
          <rect y="25" width="15" height="15" fill="${colors.inProgress}" rx="2"/>
          <text x="25" y="37" class="legend">DOING</text>
          
          <rect y="50" width="15" height="15" fill="${colors.done}" rx="2"/>
          <text x="25" y="62" class="legend">DONE</text>
          
          <text x="0" y="90" class="value">
            Per\xEDodo: ${this.sprints[0].startDate} - 
            ${this.sprints[this.sprints.length - 1].endDate}
          </text>
          <text x="0" y="110" class="value">
            Total de Tasks: ${totalTasks}
          </text>
          <text x="0" y="130" class="value">
            Total de Sprints: ${this.sprints.length}
          </text>
        </g>
      </svg>
    `;
    return svg;
  }
  generate() {
    try {
      const svg = this.generateSVG();
      fs2.writeFileSync(this.outputPath, svg);
      console.log(`CFD gerado com sucesso em: ${this.outputPath}`);
    } catch (error) {
      console.error("Erro ao gerar CFD:", error);
      throw error;
    }
  }
};

// src/documentation/service/markdown/chart/project/ProjectThroughputGenerator.ts
import * as fs3 from "fs";
var ProjectThroughputGenerator = class {
  sprints;
  outputPath;
  constructor(sprints, outputPath = "./project-throughput.svg") {
    this.sprints = this.sortSprints(sprints);
    this.outputPath = outputPath;
  }
  parseBrazilianDate(dateString) {
    const [day, month, year] = dateString.split("/").map(Number);
    return new Date(year, month - 1, day);
  }
  sortSprints(sprints) {
    return sprints.sort(
      (a, b) => this.parseBrazilianDate(a.startDate).getTime() - this.parseBrazilianDate(b.startDate).getTime()
    );
  }
  processData() {
    const formatDate = (date) => {
      const dia = date.getDate().toString().padStart(2, "0");
      const mes = (date.getMonth() + 1).toString().padStart(2, "0");
      return `${dia}/${mes}`;
    };
    const startDate = this.parseBrazilianDate(this.sprints[0].startDate);
    const endDate = this.parseBrazilianDate(this.sprints[this.sprints.length - 1].endDate);
    const days = [];
    let currentDate = new Date(startDate);
    while (currentDate <= endDate) {
      const weekDay = currentDate.toLocaleDateString("pt-BR", { weekday: "short" });
      const formattedDate = formatDate(currentDate);
      const allTasksUntilDay = this.sprints.flatMap((sprint) => {
        return sprint.sprintItems.filter((task) => {
          const taskStartDate = task.startDate ? this.parseBrazilianDate(task.startDate) : null;
          return taskStartDate ? taskStartDate <= currentDate : true;
        });
      });
      days.push({
        day: `${weekDay} ${formattedDate}`,
        date: new Date(currentDate),
        todo: allTasksUntilDay.filter((task) => task.status === "TODO").length,
        inProgress: allTasksUntilDay.filter(
          (task) => task.status === "IN_PROGRESS" || task.status === "DOING"
        ).length,
        done: allTasksUntilDay.filter((task) => task.status === "DONE").length
      });
      currentDate.setDate(currentDate.getDate() + 1);
    }
    return days;
  }
  generateSVG() {
    const width = 1200;
    const height = 600;
    const margin = { top: 50, right: 150, bottom: 100, left: 70 };
    const colors = {
      todo: "#ef4444",
      inProgress: "#f59e0b",
      done: "#22c55e",
      grid: "#e5e7eb",
      text: "#000000",
      lightText: "#666666"
    };
    const dailyData = this.processData();
    const totalTasks = this.sprints.reduce((sum, sprint) => sum + sprint.sprintItems.length, 0);
    if (totalTasks === 0) {
      throw new Error("N\xE3o h\xE1 tarefas para gerar o gr\xE1fico");
    }
    const chartWidth = width - margin.left - margin.right;
    const chartHeight = height - margin.top - margin.bottom;
    const barWidth = Math.min(chartWidth / dailyData.length * 0.8, 50);
    const barSpacing = Math.max(chartWidth / dailyData.length * 0.2, 10);
    let svg = `
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${width} ${height}">
          <defs>
            <style>
              text { font-family: Arial, sans-serif; }
              .title { font-size: 24px; font-weight: bold; }
              .label { font-size: 14px; }
              .value { font-size: 12px; fill: ${colors.lightText}; }
              .axis { font-size: 12px; }
              .legend { font-size: 14px; }
            </style>
          </defs>
          
          <rect width="${width}" height="${height}" fill="white"/>
          
          ${Array.from({ length: 11 }, (_, i) => {
      const y = margin.top + i * (chartHeight / 10);
      return `
              <line 
                x1="${margin.left}" 
                y1="${y}" 
                x2="${width - margin.right}" 
                y2="${y}" 
                stroke="${colors.grid}" 
                stroke-dasharray="4"
              />
              <text 
                x="${margin.left - 10}" 
                y="${y}" 
                text-anchor="end" 
                class="axis" 
                dominant-baseline="middle"
              >${Math.round(totalTasks - i * (totalTasks / 10))}</text>
            `;
    }).join("")}
          
          <line 
            x1="${margin.left}" 
            y1="${margin.top}" 
            x2="${margin.left}" 
            y2="${height - margin.bottom}" 
            stroke="black" 
            stroke-width="2"
          />
          <line 
            x1="${margin.left}" 
            y1="${height - margin.bottom}" 
            x2="${width - margin.right}" 
            y2="${height - margin.bottom}" 
            stroke="black" 
            stroke-width="2"
          />
          
          ${dailyData.map((day, i) => {
      if (dailyData.length <= 14 || i % 2 === 0) {
        const x = margin.left + i * (chartWidth / dailyData.length) + barSpacing / 2;
        const barHeight = chartHeight / Math.max(1, totalTasks);
        const todoHeight = day.todo * barHeight;
        const inProgressHeight = day.inProgress * barHeight;
        const doneHeight = day.done * barHeight;
        return `
                <g>
                  <rect 
                    x="${x}" 
                    y="${height - margin.bottom - todoHeight}" 
                    width="${barWidth}" 
                    height="${todoHeight}" 
                    fill="${colors.todo}"
                    rx="4"
                  />
                  
                  <rect 
                    x="${x}" 
                    y="${height - margin.bottom - todoHeight - inProgressHeight}" 
                    width="${barWidth}" 
                    height="${inProgressHeight}" 
                    fill="${colors.inProgress}"
                    rx="4"
                  />
                  
                  <rect 
                    x="${x}" 
                    y="${height - margin.bottom - todoHeight - inProgressHeight - doneHeight}" 
                    width="${barWidth}" 
                    height="${doneHeight}" 
                    fill="${colors.done}"
                    rx="4"
                  />
                  
                  <text 
                    transform="rotate(-45 ${x + barWidth / 2} ${height - margin.bottom + 20})" 
                    x="${x + barWidth / 2}" 
                    y="${height - margin.bottom + 20}" 
                    text-anchor="end" 
                    class="axis"
                  >${day.day}</text>
                  
                  ${day.todo > 0 ? `
                    <text 
                      x="${x + barWidth / 2}" 
                      y="${height - margin.bottom - todoHeight / 2}" 
                      text-anchor="middle" 
                      class="value"
                      fill="white"
                    >${day.todo}</text>
                  ` : ""}
                  
                  ${day.inProgress > 0 ? `
                    <text 
                      x="${x + barWidth / 2}" 
                      y="${height - margin.bottom - todoHeight - inProgressHeight / 2}" 
                      text-anchor="middle" 
                      class="value"
                      fill="white"
                    >${day.inProgress}</text>
                  ` : ""}
                  
                  ${day.done > 0 ? `
                    <text 
                      x="${x + barWidth / 2}" 
                      y="${height - margin.bottom - todoHeight - inProgressHeight - doneHeight / 2}" 
                      text-anchor="middle" 
                      class="value"
                      fill="white"
                    >${day.done}</text>
                  ` : ""}
                </g>
              `;
      }
      return "";
    }).join("")}
          
          <text 
            transform="rotate(-90 ${margin.left - 40} ${height / 2})" 
            x="${margin.left - 40}" 
            y="${height / 2}" 
            text-anchor="middle" 
            class="label"
          >N\xFAmero de Tarefas</text>
          
          <text 
            x="${width / 2}" 
            y="${height - 20}" 
            text-anchor="middle" 
            class="label"
          >Per\xEDodo do Projeto</text>
          
          <text 
            x="${width / 2}" 
            y="30" 
            text-anchor="middle" 
            class="title"
          >Throughput do Projeto</text>
          
          <g transform="translate(${width - margin.right + 20}, ${margin.top})">
            <rect width="15" height="15" fill="${colors.todo}" rx="2"/>
            <text x="25" y="12" class="legend">TODO</text>
            
            <rect y="25" width="15" height="15" fill="${colors.inProgress}" rx="2"/>
            <text x="25" y="37" class="legend">DOING</text>
            
            <rect y="50" width="15" height="15" fill="${colors.done}" rx="2"/>
            <text x="25" y="62" class="legend">DONE</text>
            
            <text x="0" y="90" class="value">
              Per\xEDodo: ${this.sprints[0].startDate} - 
              ${this.sprints[this.sprints.length - 1].endDate}
            </text>
            <text x="0" y="110" class="value">
              Total de Tasks: ${totalTasks}
            </text>
            <text x="0" y="130" class="value">
              Total de Sprints: ${this.sprints.length}
            </text>
          </g>
        </svg>
      `;
    return svg;
  }
  generate() {
    try {
      const svg = this.generateSVG();
      fs3.writeFileSync(this.outputPath, svg);
      console.log(`Throughput gerado com sucesso em: ${this.outputPath}`);
    } catch (error) {
      console.error("Erro ao gerar Throughput:", error);
      throw error;
    }
  }
};

// src/documentation/service/markdown/chart/project/ProjectMonteCarlo.ts
var ProjectMonteCarlo = class {
  sprints;
  simulations;
  constructor(sprintsData, simulations = 1e4) {
    if (!sprintsData || sprintsData.length === 0) {
      throw new Error("Dados de sprints inv\xE1lidos ou vazios");
    }
    this.sprints = this.sortSprints(sprintsData);
    this.simulations = simulations;
  }
  parseBrazilianDate(dateString) {
    const [day, month, year] = dateString.split("/").map(Number);
    return new Date(year, month - 1, day);
  }
  sortSprints(sprints) {
    return sprints.sort(
      (a, b) => this.parseBrazilianDate(a.startDate).getTime() - this.parseBrazilianDate(b.startDate).getTime()
    );
  }
  calculateDailyVelocity() {
    const velocities = [];
    const completedTasks = this.sprints.flatMap(
      (sprint) => sprint.sprintItems.filter((task) => task.status === "DONE")
    );
    if (completedTasks.length > 0) {
      const days = /* @__PURE__ */ new Map();
      completedTasks.forEach((task) => {
        var _a, _b;
        const date = ((_a = task.dueDate) == null ? void 0 : _a.split("T")[0]) || ((_b = task.startDate) == null ? void 0 : _b.split("T")[0]);
        if (date) {
          days.set(date, (days.get(date) || 0) + 1);
        }
      });
      days.forEach((tasksCompleted) => {
        velocities.push(tasksCompleted);
      });
    }
    return velocities.length > 0 ? velocities : [1];
  }
  getProjectMetrics() {
    const totalTasks = this.sprints.reduce((sum, sprint) => sum + sprint.sprintItems.length, 0);
    const completedTasks = this.sprints.reduce(
      (sum, sprint) => sum + sprint.sprintItems.filter((t) => t.status === "DONE").length,
      0
    );
    const remainingTasks = totalTasks - completedTasks;
    const today = /* @__PURE__ */ new Date();
    const endDate = this.parseBrazilianDate(this.sprints[this.sprints.length - 1].endDate);
    const diffTime = endDate.getTime() - today.getTime();
    const remainingDays = Math.max(1, Math.ceil(diffTime / (1e3 * 60 * 60 * 24)));
    const velocities = this.calculateDailyVelocity();
    const avgVelocity = velocities.reduce((a, b) => a + b, 0) / Math.max(velocities.length, 1);
    return {
      totalTasks,
      completedTasks,
      remainingTasks,
      remainingDays,
      avgVelocity,
      currentVelocity: velocities[velocities.length - 1] || avgVelocity
    };
  }
  simulateCompletionDates() {
    const velocities = this.calculateDailyVelocity();
    const metrics = this.getProjectMetrics();
    const completionDates = [];
    for (let i = 0; i < this.simulations; i++) {
      let simulatedCompleted = metrics.completedTasks;
      let currentDate = /* @__PURE__ */ new Date();
      let daysAdded = 0;
      while (simulatedCompleted < metrics.totalTasks) {
        if (currentDate.getDay() !== 0 && currentDate.getDay() !== 6) {
          const dailyVelocity = velocities[Math.floor(Math.random() * velocities.length)];
          simulatedCompleted += dailyVelocity;
        }
        currentDate = new Date(currentDate.setDate(currentDate.getDate() + 1));
        daysAdded++;
        if (daysAdded > 90) break;
      }
      if (simulatedCompleted >= metrics.totalTasks) {
        completionDates.push(currentDate);
      }
    }
    if (completionDates.length === 0) {
      completionDates.push(this.parseBrazilianDate(this.sprints[this.sprints.length - 1].endDate));
    }
    const dateFrequencyMap = /* @__PURE__ */ new Map();
    completionDates.forEach((date) => {
      const dateStr = date.toISOString().split("T")[0];
      dateFrequencyMap.set(dateStr, (dateFrequencyMap.get(dateStr) || 0) + 1);
    });
    return Array.from(dateFrequencyMap.entries()).sort(([a], [b]) => a.localeCompare(b)).map(([dateStr, frequency], _, arr) => {
      const cumulativeFrequency = arr.filter(([d]) => d <= dateStr).reduce((sum, [, f]) => sum + f, 0);
      return {
        date: new Date(dateStr),
        tasksCompleted: metrics.totalTasks,
        probability: frequency / this.simulations * 100,
        cumulativeProbability: cumulativeFrequency / this.simulations * 100
      };
    });
  }
  formatDate(date) {
    return date.toLocaleDateString("pt-BR", {
      weekday: "short",
      day: "2-digit",
      month: "2-digit",
      year: "numeric"
    });
  }
  getDateStatus(predictedDate, plannedDate) {
    const diffDays = Math.round((predictedDate.getTime() - plannedDate.getTime()) / (1e3 * 60 * 60 * 24));
    if (diffDays < 0) return "\u2705 Antes do Prazo";
    if (diffDays === 0) return "\u2705 No Prazo";
    if (diffDays <= 5) return "\u26A0\uFE0F Pequeno Atraso";
    if (diffDays <= 15) return "\u26A0\uFE0F Atraso Moderado";
    return "\u274C Atraso Cr\xEDtico";
  }
  getCompletionStatus(probability) {
    if (probability >= 85) return "\u2705 PROJETO PROVAVELMENTE SER\xC1 CONCLU\xCDDO NO PRAZO";
    if (probability >= 50) return "\u26A0\uFE0F RISCO MODERADO DE ATRASO NO PROJETO";
    return "\u274C ALTO RISCO DE ATRASO NO PROJETO";
  }
  generateMarkdownReport() {
    var _a;
    try {
      const metrics = this.getProjectMetrics();
      if (metrics.totalTasks === 0) {
        return `

 ## Relat\xF3rio de Previs\xE3o do Projeto - M\xE9todo Monte Carlo

### \u26A0\uFE0F DADOS INSUFICIENTES PARA AN\xC1LISE

N\xE3o h\xE1 tarefas registradas no projeto para realizar a an\xE1lise.

`;
      }
      const completionDates = this.simulateCompletionDates();
      const projectEndDate = this.parseBrazilianDate(this.sprints[this.sprints.length - 1].endDate);
      const onTimeProb = ((_a = completionDates.find((d) => d.date > projectEndDate)) == null ? void 0 : _a.cumulativeProbability) || 100;
      let mostLikelyDate = completionDates[0];
      if (completionDates.length > 1) {
        mostLikelyDate = completionDates.reduce(
          (prev, current) => current.probability > prev.probability ? current : prev
        );
      }
      let markdown = `

 ## Previs\xE3o do Projeto 

`;
      markdown += `## \u{1F3AF} Conclus\xE3o Principal

`;
      markdown += `### ${this.getCompletionStatus(onTimeProb)}

`;
      markdown += `- **Probabilidade de conclus\xE3o no prazo**: ${onTimeProb.toFixed(1)}%
`;
      markdown += `- **Data mais prov\xE1vel de conclus\xE3o**: ${this.formatDate(mostLikelyDate.date)}
`;
      const diffDays = Math.round((mostLikelyDate.date.getTime() - projectEndDate.getTime()) / (1e3 * 60 * 60 * 24));
      markdown += `- **Dias em rela\xE7\xE3o ao planejado**: ${diffDays} dias
`;
      markdown += `- **Status**: ${this.getDateStatus(mostLikelyDate.date, projectEndDate)}

`;
      markdown += `### \u{1F4CA} M\xE9tricas do Projeto

`;
      markdown += `| M\xE9trica | Valor | Status |
`;
      markdown += `|---------|--------|--------|
`;
      const velocidadeNecessaria = metrics.remainingTasks / metrics.remainingDays;
      const velocidadeStatus = metrics.avgVelocity >= velocidadeNecessaria ? "\u2705" : "\u274C";
      markdown += `| Velocidade Atual | ${metrics.avgVelocity.toFixed(1)} tarefas/dia | ${velocidadeStatus} |
`;
      markdown += `| Velocidade Necess\xE1ria | ${velocidadeNecessaria.toFixed(1)} tarefas/dia | - |
`;
      markdown += `| Dias Restantes | ${metrics.remainingDays} dias | - |
`;
      markdown += `| Tarefas Restantes | ${metrics.remainingTasks} tarefas | - |

`;
      markdown += `### \u{1F4C5} Previs\xF5es de Data de Conclus\xE3o

`;
      markdown += `| Data | Probabilidade | Status | Observa\xE7\xE3o |
`;
      markdown += `|------|---------------|---------|------------|
`;
      completionDates.forEach((result) => {
        const diffDays2 = Math.round((result.date.getTime() - projectEndDate.getTime()) / (1e3 * 60 * 60 * 24));
        let observation = "";
        if (result.probability === Math.max(...completionDates.map((d) => d.probability))) {
          observation = "\u{1F4CD} Data mais prov\xE1vel";
        } else if (diffDays2 <= 0) {
          observation = "\u{1F3AF} Dentro do prazo";
        }
        markdown += `| ${this.formatDate(result.date)} | ${result.probability.toFixed(1)}% | ${this.getDateStatus(result.date, projectEndDate)} | ${observation} |
`;
      });
      markdown += `
## \u{1F4A1} Recomenda\xE7\xF5es

`;
      if (onTimeProb >= 85) {
        markdown += `1. \u2705 Manter o ritmo atual de ${metrics.avgVelocity.toFixed(1)} tarefas/dia
`;
        markdown += `2. \u2705 Continuar monitorando impedimentos
`;
        markdown += `3. \u2705 Planejar pr\xF3ximas sprints com anteced\xEAncia
`;
      } else if (onTimeProb >= 50) {
        markdown += `1. \u26A0\uFE0F Aumentar velocidade para ${velocidadeNecessaria.toFixed(1)} tarefas/dia
`;
        markdown += `2. \u26A0\uFE0F Priorizar tarefas cr\xEDticas
`;
        markdown += `3. \u26A0\uFE0F Remover impedimentos imediatamente
`;
      } else {
        markdown += `1. \u274C Realizar reuni\xE3o de emerg\xEAncia
`;
        markdown += `2. \u274C Reavaliar escopo do projeto
`;
        markdown += `3. \u274C Considerar adi\xE7\xE3o de recursos ou redu\xE7\xE3o de escopo
`;
      }
      markdown += `
## \u2139\uFE0F Informa\xE7\xF5es do Projeto

`;
      markdown += `- **Total de Sprints**: ${this.sprints.length}
`;
      markdown += `- **In\xEDcio**: ${this.formatDate(this.parseBrazilianDate(this.sprints[0].startDate))}
`;
      markdown += `- **T\xE9rmino Planejado**: ${this.formatDate(projectEndDate)}
`;
      markdown += `- **Total de Tarefas**: ${metrics.totalTasks}
`;
      markdown += `- **Simula\xE7\xF5es Realizadas**: ${this.simulations.toLocaleString()}

`;
      markdown += `---
*Relat\xF3rio gerado em ${(/* @__PURE__ */ new Date()).toLocaleString("pt-BR")}*`;
      return markdown;
    } catch (error) {
      console.error("Erro ao gerar relat\xF3rio Monte Carlo:", error);
      return `

 ## Relat\xF3rio de Previs\xE3o do Projeto - M\xE9todo Monte Carlo

### \u274C ERRO AO GERAR RELAT\xD3RIO

Ocorreu um erro ao processar os dados do projeto. Por favor, verifique os dados e tente novamente.

`;
    }
  }
};

// src/documentation/service/markdown/chart/project/ProjectMetricsGenerator.ts
var ProjectMetricsGenerator = class {
  sprints;
  constructor(sprints) {
    this.sprints = sprints;
  }
  parseBrazilianDate(dateStr) {
    if (!dateStr) {
      throw new Error("Data n\xE3o fornecida");
    }
    dateStr = dateStr.trim();
    const dateRegex = /^(\d{2})\/(\d{2})\/(\d{4})$/;
    const match = dateStr.match(dateRegex);
    if (!match) {
      throw new Error(`Data inv\xE1lida: ${dateStr}. Formato esperado: dd/mm/yyyy`);
    }
    const [, day, month, year] = match;
    const date = /* @__PURE__ */ new Date(`${year}-${month}-${day}`);
    if (isNaN(date.getTime())) {
      throw new Error(`Data inv\xE1lida ap\xF3s convers\xE3o: ${dateStr}`);
    }
    return date;
  }
  formatDate(date) {
    try {
      const parsedDate = this.parseBrazilianDate(date);
      return parsedDate.toLocaleDateString("pt-BR", {
        day: "2-digit",
        month: "2-digit"
      });
    } catch (error) {
      console.error(`Erro ao formatar data: ${this.getErrorMessage(error)}`);
      return date;
    }
  }
  calculateDuration(startDate, endDate) {
    try {
      const start = this.parseBrazilianDate(startDate);
      const end = this.parseBrazilianDate(endDate);
      const startTime = start.getTime();
      const endTime = end.getTime();
      if (endTime < startTime) {
        throw new Error("Data de fim \xE9 anterior \xE0 data de in\xEDcio");
      }
      return Math.ceil((endTime - startTime) / (1e3 * 60 * 60 * 24));
    } catch (error) {
      console.error(`Erro ao calcular dura\xE7\xE3o entre ${startDate} e ${endDate}: ${this.getErrorMessage(error)}`);
      throw new Error(`Erro ao calcular dura\xE7\xE3o: ${this.getErrorMessage(error)}`);
    }
  }
  getErrorMessage(error) {
    if (error instanceof Error) {
      return error.message;
    }
    if (typeof error === "string") {
      return error;
    }
    if (error && typeof error === "object" && "toString" in error) {
      return error.toString();
    }
    return "Erro desconhecido";
  }
  analyzeTaskStatus(tasks) {
    return {
      completed: tasks.filter((task) => task.status === "DONE").length,
      inProgress: tasks.filter(
        (task) => task.status !== "DONE" && task.startDate
      ).length,
      pending: tasks.filter(
        (task) => task.status !== "DONE" && !task.startDate
      ).length
    };
  }
  calculateVelocity(tasks, duration) {
    const completedTasks = tasks.filter((task) => task.status === "DONE").length;
    return Number((completedTasks / duration).toFixed(2));
  }
  generateSprintSVG(sprints) {
    const width = 800;
    const height = 400;
    const margin = { top: 40, right: 40, bottom: 60, left: 60 };
    const graphWidth = width - margin.left - margin.right;
    const graphHeight = height - margin.top - margin.bottom;
    const getCompletedTasks = (tasks) => tasks.filter((t) => t.status === "Conclu\xEDdo").length;
    const maxTasks = Math.max(...sprints.map((s) => s.sprintItems.length));
    const barWidth = graphWidth / (sprints.length * 2);
    let svg = `
        <svg viewBox="0 0 ${width} ${height}" xmlns="http://www.w3.org/2000/svg">
            <style>
                .bar { fill: #4f46e5; opacity: 0.8; }
                .bar:hover { opacity: 1; }
                .label { font-size: 12px; font-family: Arial; }
            </style>
            <g transform="translate(${margin.left}, ${margin.top})">`;
    svg += `
        <line x1="0" y1="0" x2="0" y2="${graphHeight}" stroke="black" stroke-width="2"/>
        <line x1="0" y1="${graphHeight}" x2="${graphWidth}" y2="${graphHeight}" stroke="black" stroke-width="2"/>`;
    for (let i = 0; i <= 4; i++) {
      const yValue = maxTasks * (4 - i) / 4;
      svg += `
            <text x="-10" y="${graphHeight * i / 4}" 
                  text-anchor="end" dominant-baseline="middle" 
                  class="label">${Math.round(yValue)}</text>`;
    }
    sprints.forEach((sprint, i) => {
      const completedTasks = getCompletedTasks(sprint.sprintItems);
      const barHeight = completedTasks / maxTasks * graphHeight;
      const x = i * graphWidth / sprints.length;
      svg += `
            <g>
                <rect x="${x + barWidth / 2}" y="${graphHeight - barHeight}"
                      width="${barWidth}" height="${barHeight}" class="bar">
                    <title>${sprint.name}: ${completedTasks}/${sprint.sprintItems.length} tasks completed</title>
                </rect>
                <text x="${x + barWidth}" y="${graphHeight + 20}"
                      text-anchor="middle" class="label"
                      transform="rotate(45, ${x + barWidth}, ${graphHeight + 20})">${sprint.name}</text>
            </g>`;
    });
    svg += `
            </g>
        </svg>`;
    return svg;
  }
  generateSummaryTable() {
    let markdown = "## M\xE9tricas Consolidadas\n\n";
    markdown += "| Sprint | Per\xEDodo | Dura\xE7\xE3o | Total Tasks | Conclu\xEDdas | Em Progresso | Pendentes | Velocidade | Efici\xEAncia |\n";
    markdown += "|--------|---------|----------|-------------|------------|--------------|-----------|------------|------------|\n";
    this.sprints.forEach((sprint) => {
      const duration = this.calculateDuration(sprint.startDate, sprint.endDate);
      const status = this.analyzeTaskStatus(sprint.sprintItems);
      const velocity = this.calculateVelocity(sprint.sprintItems, duration);
      const efficiency = (status.completed / sprint.sprintItems.length * 100).toFixed(1);
      markdown += `| ${sprint.name} | ${this.formatDate(sprint.startDate)} - ${this.formatDate(sprint.endDate)} | ${duration} dias | ${sprint.sprintItems.length} | ${status.completed} (${efficiency}%) | ${status.inProgress} | ${status.pending} | ${velocity}/dia | ${efficiency}% |
`;
    });
    return markdown;
  }
  generateMarkdownReport(project) {
    let markdown = "# \u{1F4CA} Vis\xE3o Geral do Projeto \n\n";
    markdown += `${project.description ?? "-"}
`;
    markdown += `* Data de In\xEDcio: ${project.startDate ?? "-"}
`;
    markdown += `* Data de Planejado: ${project.dueDate ?? "-"}
`;
    markdown += `* Data de Finaliza\xE7\xE3o: ${project.completedDate ?? "-"}

`;
    markdown += `${project.description}
`;
    markdown += this.generateSummaryTable() + "\n";
    const totalTasks = this.sprints.reduce((acc, sprint) => acc + sprint.sprintItems.length, 0);
    const totalStatus = this.analyzeTaskStatus(this.sprints.flatMap((s) => s.sprintItems));
    const globalEfficiency = (totalStatus.completed / totalTasks * 100).toFixed(1);
    markdown += "## An\xE1lise Geral\n\n";
    markdown += `- **Total de Sprints:** ${this.sprints.length}
`;
    markdown += `- **Total de Tasks:** ${totalTasks}
`;
    markdown += `- **Taxa de Conclus\xE3o:** ${globalEfficiency}%

`;
    markdown += "### Notas\n";
    markdown += `- Per\xEDodo Total: ${this.formatDate(this.sprints[0].startDate)} - ${this.formatDate(this.sprints[this.sprints.length - 1].endDate)}
`;
    markdown += `- M\xE9dia de Dura\xE7\xE3o das Sprints: ${Math.round(this.sprints.reduce((acc, sprint) => acc + this.calculateDuration(sprint.startDate, sprint.endDate), 0) / this.sprints.length)} dias

`;
    markdown += `*\xDAltima atualiza\xE7\xE3o: ${(/* @__PURE__ */ new Date()).toLocaleDateString("pt-BR", {
      month: "long",
      year: "numeric"
    })}*`;
    markdown += "\n\n## Cumulative Flow \n";
    markdown += "![ Cumulative Flow](./project-cfd.svg)\n\n";
    const projectAnalysis = new ProjectMonteCarlo(this.sprints);
    const report = projectAnalysis.generateMarkdownReport();
    markdown += report;
    return markdown;
  }
  async generateFiles(outputDir, project) {
    try {
      if (!fs4.existsSync(outputDir)) {
        fs4.mkdirSync(outputDir, { recursive: true });
      }
      const svgPath = path2.join(outputDir, "project-cfd.svg");
      const projectCFD = new ProjectCFD(this.sprints, svgPath);
      projectCFD.generate();
      const svgPathTP = path2.join(outputDir, "project-throughput.svg");
      const throughput = new ProjectThroughputGenerator(this.sprints, svgPathTP);
      throughput.generate();
      const markdown = this.generateMarkdownReport(project);
      const markdownPath = path2.join(outputDir, "01_overview.md");
      await fs4.promises.writeFile(markdownPath, markdown, "utf-8");
    } catch (error) {
      console.error("Erro ao gerar arquivos:", error);
      throw error;
    }
  }
};

// src/documentation/service/markdown/report/BacklogReport.ts
var BacklogMarkdownConverter = class {
  getTypeEmoji(type) {
    switch (type.toLowerCase()) {
      case "epic":
        return "\u{1F31F}";
      case "atomicuserstory":
      case "userstory":
        return "\u2B50";
      case "taskbacklog":
      case "task":
        return "\u2705";
      default:
        return "";
    }
  }
  formatDisplayType(type) {
    switch (type.toLowerCase()) {
      case "epic":
        return "Epic";
      case "atomicuserstory":
        return "Story";
      case "taskbacklog":
        return "Task";
      default:
        return type;
    }
  }
  formatIssueForTable(issue, level = 0) {
    var _a;
    const titlePrefix = "  ".repeat(level);
    const typeEmoji = this.getTypeEmoji(issue.type);
    const displayType = this.formatDisplayType(issue.type);
    const typeWithEmoji = typeEmoji ? `${typeEmoji} ${displayType}` : displayType;
    const row = [
      `${titlePrefix}${issue.id.toLocaleLowerCase()}`,
      typeWithEmoji,
      issue.title || "-",
      issue.description || "-",
      issue.status || "-",
      ((_a = issue.depends) == null ? void 0 : _a.map((d) => d.id).join(", ")) || "-"
    ];
    let rows = [row.join(" | ")];
    if (issue.issues && issue.issues.length > 0) {
      issue.issues.forEach((subIssue) => {
        rows = rows.concat(this.formatIssueForTable(subIssue, level + 1));
      });
    }
    return rows;
  }
  convertBacklogsToMarkdown(backlogs) {
    let markdown = "# \u{1F4CB} Backlogs\n\n";
    const headers = [
      "ID",
      "Tipo",
      "T\xEDtulo",
      "Descri\xE7\xE3o",
      "Status",
      "Depend\xEAncias"
    ];
    backlogs.forEach((backlog, index) => {
      markdown += `## ${backlog.name}

`;
      if (backlog.description) {
        markdown += `${backlog.description}

`;
      }
      if (backlog.issues && backlog.issues.length > 0) {
        markdown += "### Issues\n\n";
        markdown += `| ${headers.join(" | ")} |
`;
        markdown += `| ${headers.map(() => "---").join(" | ")} |
`;
        backlog.issues.forEach((issue) => {
          const rows = this.formatIssueForTable(issue);
          rows.forEach((row) => {
            markdown += `| ${row} |
`;
          });
        });
        markdown += "\n";
      } else {
        markdown += "Nenhuma issue encontrada neste backlog.\n\n";
      }
      if (index < backlogs.length - 1) {
        markdown += "---\n\n";
      }
    });
    return markdown;
  }
};

// src/documentation/service/markdown/MarkdownBacklogService.ts
var MarkdownBacklogService = class {
  target_folder;
  jsonTimeBox;
  jsonFileBacklog;
  DB_PATH;
  sprintData;
  constructor(target_folder, db_path) {
    this.target_folder = target_folder;
    this.jsonTimeBox = "timebox.json";
    this.jsonFileBacklog = "backlog.json";
    this.DB_PATH = db_path;
    this.sprintData = [];
  }
  async create() {
    const backlogs = await this.retrive(this.jsonFileBacklog);
    const converter = new BacklogMarkdownConverter();
    const markdown = converter.convertBacklogsToMarkdown(backlogs);
    const outputDirBacklolg = path3.join(this.target_folder, "02_backlogs.md");
    fs5.writeFileSync(outputDirBacklolg, markdown, "utf8");
    this.sprintData = await this.retrive(this.jsonTimeBox);
    const project = await this.retrive("project.json");
    const project_x = project[0];
    const generator = new ProjectMetricsGenerator(this.sprintData);
    try {
      await generator.generateFiles(this.target_folder, project_x);
    } catch (error) {
      console.error("Erro ao gerar relat\xF3rios:", error);
    }
  }
  async retrive(database) {
    const ISSUEPATH = path3.join(this.DB_PATH, database);
    const adapter = new JSONFileSync(ISSUEPATH);
    const defaultData = { data: [] };
    const db = new LowSync(adapter, defaultData);
    await db.read();
    return db.data.data.sort((a, b) => {
      return Number(a.id) - Number(b.id);
    });
  }
};

// src/documentation/service/markdown/MarkdownTimeBoxService.ts
import * as path4 from "path";
import * as fs7 from "fs";
import { readdirSync } from "fs";
import { LowSync as LowSync2 } from "lowdb";
import { JSONFileSync as JSONFileSync2 } from "lowdb/node";

// src/documentation/service/markdown/chart/sprint/CumulativeFlowDiagram.ts
import * as fs6 from "fs";
var CumulativeFlowDiagram = class {
  data;
  outputPath;
  constructor(sprintData, outputPath = "./cfd.svg") {
    if (!sprintData) {
      throw new Error("Dados da sprint n\xE3o fornecidos");
    }
    this.data = sprintData;
    this.outputPath = outputPath;
  }
  parseBrazilianDate(dateString) {
    try {
      const [day, month, year] = dateString.split("/").map(Number);
      const date = new Date(year, month - 1, day);
      if (isNaN(date.getTime())) {
        throw new Error(`Data inv\xE1lida: ${dateString}`);
      }
      return date;
    } catch (error) {
      throw new Error(`Erro ao processar data ${dateString}: ${error}`);
    }
  }
  formatDate(date) {
    const dia = date.getDate().toString().padStart(2, "0");
    const mes = (date.getMonth() + 1).toString().padStart(2, "0");
    return `${dia}/${mes}`;
  }
  processData() {
    try {
      const startDate = this.parseBrazilianDate(this.data.startDate);
      const endDate = this.parseBrazilianDate(this.data.endDate);
      if (endDate < startDate) {
        throw new Error("Data de fim \xE9 anterior \xE0 data de in\xEDcio");
      }
      const days = [];
      let currentDate = new Date(startDate);
      while (currentDate <= endDate) {
        const weekDay = currentDate.toLocaleDateString("pt-BR", { weekday: "short" });
        const formattedDate = this.formatDate(currentDate);
        const issueStates = this.data.sprintItems.map((issue) => {
          if (!issue.startDate) return "todo";
          const startDate2 = this.parseBrazilianDate(issue.startDate);
          if (startDate2 > currentDate) return "todo";
          if (issue.completedDate) {
            const completedDate = this.parseBrazilianDate(issue.completedDate);
            if (completedDate <= currentDate) return "done";
          }
          if (startDate2 <= currentDate) return "inProgress";
          return "todo";
        });
        const statusCounts = {
          todo: issueStates.filter((state) => state === "todo").length,
          inProgress: issueStates.filter((state) => state === "inProgress").length,
          done: issueStates.filter((state) => state === "done").length
        };
        days.push({
          day: `${weekDay} ${formattedDate}`,
          date: new Date(currentDate),
          ...statusCounts
        });
        currentDate.setDate(currentDate.getDate() + 1);
      }
      return days;
    } catch (error) {
      console.error("Erro ao processar dados:", error);
      throw error;
    }
  }
  generateSVG() {
    const width = 1200;
    const height = 600;
    const margin = { top: 50, right: 150, bottom: 100, left: 70 };
    const colors = {
      todo: "#ef4444",
      inProgress: "#f59e0b",
      done: "#22c55e",
      grid: "#e5e7eb",
      text: "#000000",
      lightText: "#666666"
    };
    try {
      const dailyData = this.processData();
      const totalIssues = this.data.sprintItems.length;
      if (totalIssues === 0) {
        throw new Error("N\xE3o h\xE1 issues para gerar o gr\xE1fico");
      }
      const chartWidth = width - margin.left - margin.right;
      const chartHeight = height - margin.top - margin.bottom;
      const xScale = (date) => {
        const startDate = this.parseBrazilianDate(this.data.startDate);
        const totalDays = Math.max(1, dailyData.length - 1);
        const dayIndex = Math.floor((date.getTime() - startDate.getTime()) / (1e3 * 60 * 60 * 24));
        return margin.left + dayIndex * (chartWidth / totalDays);
      };
      const yScale = (value) => {
        return height - margin.bottom - value * (chartHeight / Math.max(1, totalIssues));
      };
      const generateArea = (data, getValue) => {
        if (data.length === 0) return "";
        const points = data.map((d) => {
          const x = xScale(d.date);
          const y = yScale(getValue(d));
          return `${x},${y}`;
        });
        const bottomPoints = data.map((d) => {
          const x = xScale(d.date);
          return `${x},${height - margin.bottom}`;
        }).reverse();
        return `M${points.join(" L")} L${bottomPoints.join(" L")} Z`;
      };
      const svg = `
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${width} ${height}">
          <defs>
            <style>
              text { font-family: Arial, sans-serif; }
              .title { font-size: 24px; font-weight: bold; }
              .label { font-size: 14px; }
              .value { font-size: 12px; fill: ${colors.lightText}; }
              .axis { font-size: 12px; }
              .legend { font-size: 14px; }
            </style>
          </defs>

          <rect width="${width}" height="${height}" fill="white"/>

          ${Array.from({ length: 11 }, (_, i) => {
        const y = margin.top + i * (chartHeight / 10);
        return `
              <line 
                x1="${margin.left}" 
                y1="${y}" 
                x2="${width - margin.right}" 
                y2="${y}" 
                stroke="${colors.grid}" 
                stroke-dasharray="4"
              />
              <text 
                x="${margin.left - 10}" 
                y="${y}" 
                text-anchor="end" 
                class="axis" 
                dominant-baseline="middle"
              >${Math.round(totalIssues - i * (totalIssues / 10))}</text>
            `;
      }).join("")}

          <path 
            d="${generateArea(dailyData, (d) => d.todo + d.inProgress + d.done)}" 
            fill="${colors.todo}" 
            opacity="0.8"
          />
          <path 
            d="${generateArea(dailyData, (d) => d.inProgress + d.done)}" 
            fill="${colors.inProgress}" 
            opacity="0.8"
          />
          <path 
            d="${generateArea(dailyData, (d) => d.done)}" 
            fill="${colors.done}" 
            opacity="0.8"
          />

          <line 
            x1="${margin.left}" 
            y1="${margin.top}" 
            x2="${margin.left}" 
            y2="${height - margin.bottom}" 
            stroke="black" 
            stroke-width="2"
          />
          <line 
            x1="${margin.left}" 
            y1="${height - margin.bottom}" 
            x2="${width - margin.right}" 
            y2="${height - margin.bottom}" 
            stroke="black" 
            stroke-width="2"
          />

          ${dailyData.map((d, i) => {
        if (dailyData.length <= 14 || i % 2 === 0) {
          const x = xScale(d.date);
          return `
                <text 
                  transform="rotate(-45 ${x} ${height - margin.bottom + 20})"
                  x="${x}"
                  y="${height - margin.bottom + 20}"
                  text-anchor="end"
                  class="axis"
                >${d.day}</text>
              `;
        }
        return "";
      }).join("")}

          <text 
            transform="rotate(-90 ${margin.left - 40} ${height / 2})" 
            x="${margin.left - 40}" 
            y="${height / 2}" 
            text-anchor="middle" 
            class="label"
          >N\xFAmero de Tarefas</text>

          <text 
            x="${width / 2}" 
            y="${height - 20}" 
            text-anchor="middle" 
            class="label"
          >Dias da Sprint</text>

          <text 
            x="${width / 2}" 
            y="30" 
            text-anchor="middle" 
            class="title"
          >${this.data.name} - Cumulative Flow Diagram</text>

          <g transform="translate(${width - margin.right + 20}, ${margin.top})">
            <rect width="15" height="15" fill="${colors.todo}" rx="2"/>
            <text x="25" y="12" class="legend">A Fazer</text>
            
            <rect y="25" width="15" height="15" fill="${colors.inProgress}" rx="2"/>
            <text x="25" y="37" class="legend">Em Andamento</text>
            
            <rect y="50" width="15" height="15" fill="${colors.done}" rx="2"/>
            <text x="25" y="62" class="legend">Conclu\xEDdo</text>
            
            <text x="0" y="90" class="value">
              Per\xEDodo: ${this.data.startDate} - ${this.data.endDate}
            </text>
            <text x="0" y="110" class="value">
              Total de Issues: ${totalIssues}
            </text>
          </g>
        </svg>
      `;
      return svg;
    } catch (error) {
      console.error("Erro ao gerar SVG:", error);
      throw error;
    }
  }
  generate() {
    try {
      const svg = this.generateSVG();
      fs6.writeFileSync(this.outputPath, svg);
      console.log(`CFD gerado com sucesso em: ${this.outputPath}`);
    } catch (error) {
      console.error("Erro ao gerar CFD:", error);
      throw error;
    }
  }
};

// src/documentation/service/markdown/chart/sprint/MonteCarlo.ts
var SprintMonteCarlo = class {
  data;
  simulations;
  constructor(sprintData, simulations = 1e4) {
    if (!sprintData) {
      throw new Error("Dados da sprint n\xE3o fornecidos");
    }
    this.data = sprintData;
    this.simulations = simulations;
  }
  parseBrazilianDate(dateString) {
    try {
      const [day, month, year] = dateString.split("/").map(Number);
      const date = new Date(year, month - 1, day);
      if (isNaN(date.getTime())) {
        throw new Error(`Data inv\xE1lida: ${dateString}`);
      }
      return date;
    } catch (error) {
      throw new Error(`Erro ao processar data ${dateString}: ${error}`);
    }
  }
  calculateDailyVelocity() {
    var _a;
    const completedTasks = (_a = this.data.sprintItems) == null ? void 0 : _a.filter(
      (task) => task.status === "DONE" || task.status === "Conclu\xEDdo"
    );
    const velocities = [];
    if (completedTasks && completedTasks.length > 0) {
      const days = /* @__PURE__ */ new Map();
      completedTasks.forEach((task) => {
        var _a2;
        const date = ((_a2 = task.startDate) == null ? void 0 : _a2.split("T")[0]) || task.startDate;
        if (date) {
          days.set(date, (days.get(date) || 0) + 1);
        }
      });
      days.forEach((tasksCompleted) => {
        velocities.push(tasksCompleted);
      });
    }
    return velocities.length > 0 ? velocities : [1];
  }
  calculateRemainingWorkdays() {
    try {
      const today = /* @__PURE__ */ new Date();
      const endDate = this.parseBrazilianDate(this.data.endDate);
      const diffTime = endDate.getTime() - today.getTime();
      const diffDays = Math.ceil(diffTime / (1e3 * 60 * 60 * 24));
      return Math.max(1, diffDays);
    } catch (error) {
      console.error("Erro ao calcular dias restantes:", error);
      return 1;
    }
  }
  getSprintMetrics() {
    const totalTasks = this.data.sprintItems.length;
    const completedTasks = this.data.sprintItems.filter(
      (t) => t.status === "DONE" || t.status === "Conclu\xEDdo"
    ).length;
    const remainingTasks = totalTasks - completedTasks;
    const remainingDays = this.calculateRemainingWorkdays();
    const velocities = this.calculateDailyVelocity();
    const avgVelocity = velocities.reduce((a, b) => a + b, 0) / Math.max(velocities.length, 1);
    return {
      totalTasks,
      completedTasks,
      remainingTasks,
      remainingDays,
      avgVelocity,
      currentVelocity: velocities[velocities.length - 1] || avgVelocity
    };
  }
  simulateCompletionDates() {
    const velocities = this.calculateDailyVelocity();
    const metrics = this.getSprintMetrics();
    const completionDates = [];
    for (let i = 0; i < this.simulations; i++) {
      let simulatedCompleted = metrics.completedTasks;
      let currentDate = /* @__PURE__ */ new Date();
      let daysAdded = 0;
      while (simulatedCompleted < metrics.totalTasks) {
        if (currentDate.getDay() !== 0 && currentDate.getDay() !== 6) {
          const dailyVelocity = velocities[Math.floor(Math.random() * velocities.length)];
          simulatedCompleted += dailyVelocity;
        }
        currentDate = new Date(currentDate.setDate(currentDate.getDate() + 1));
        daysAdded++;
        if (daysAdded > 30) break;
      }
      if (simulatedCompleted >= metrics.totalTasks) {
        completionDates.push(currentDate);
      }
    }
    if (completionDates.length === 0) {
      completionDates.push(this.parseBrazilianDate(this.data.endDate));
    }
    const dateFrequencyMap = /* @__PURE__ */ new Map();
    completionDates.forEach((date) => {
      const dateStr = date.toISOString().split("T")[0];
      dateFrequencyMap.set(dateStr, (dateFrequencyMap.get(dateStr) || 0) + 1);
    });
    const results = [];
    let cumulativeFrequency = 0;
    Array.from(dateFrequencyMap.entries()).sort(([a], [b]) => a.localeCompare(b)).forEach(([dateStr, frequency]) => {
      cumulativeFrequency += frequency;
      results.push({
        date: new Date(dateStr),
        tasksCompleted: metrics.totalTasks,
        probability: frequency / this.simulations * 100,
        cumulativeProbability: cumulativeFrequency / this.simulations * 100
      });
    });
    return results;
  }
  formatDate(date) {
    try {
      return date.toLocaleDateString("pt-BR", {
        weekday: "short",
        day: "2-digit",
        month: "2-digit",
        year: "numeric"
      });
    } catch (error) {
      console.error("Erro ao formatar data:", error);
      return date.toISOString().split("T")[0];
    }
  }
  getDateStatus(predictedDate, plannedDate) {
    const diffDays = Math.round((predictedDate.getTime() - plannedDate.getTime()) / (1e3 * 60 * 60 * 24));
    if (diffDays < 0) return "\u2705 Antes do Prazo";
    if (diffDays === 0) return "\u2705 No Prazo";
    if (diffDays <= 2) return "\u26A0\uFE0F Pequeno Atraso";
    if (diffDays <= 5) return "\u26A0\uFE0F Atraso Moderado";
    return "\u274C Atraso Cr\xEDtico";
  }
  getCompletionStatus(probability) {
    if (probability >= 85) return "\u2705 SPRINT PROVAVELMENTE SER\xC1 CONCLU\xCDDA NO PRAZO";
    if (probability >= 50) return "\u26A0\uFE0F RISCO MODERADO DE ATRASO NA SPRINT";
    return "\u274C ALTO RISCO DE ATRASO NA SPRINT";
  }
  generateMarkdownReport() {
    var _a, _b, _c, _d;
    try {
      const completionDates = this.simulateCompletionDates();
      const metrics = this.getSprintMetrics();
      const sprintEndDate = this.parseBrazilianDate(this.data.endDate);
      if (metrics.totalTasks === 0) {
        return "# Relat\xF3rio de Previs\xE3o da Sprint\n\n\u26A0\uFE0F N\xE3o h\xE1 tarefas registradas para an\xE1lise.";
      }
      const onTimeProb = ((_a = completionDates.find((d) => d.date > sprintEndDate)) == null ? void 0 : _a.cumulativeProbability) || 100;
      let mostLikelyDate = completionDates[0];
      if (completionDates.length > 1) {
        mostLikelyDate = completionDates.reduce(
          (prev, current) => current.probability > prev.probability ? current : prev
        );
      }
      let markdown = `# Previs\xE3o da Sprint

`;
      markdown += `## ${this.getCompletionStatus(onTimeProb)}

`;
      markdown += `- **Probabilidade de conclus\xE3o no prazo**: ${onTimeProb.toFixed(1)}%
`;
      markdown += `- **Data mais prov\xE1vel de conclus\xE3o**: ${this.formatDate(mostLikelyDate.date)}
`;
      const diffDays = Math.round((mostLikelyDate.date.getTime() - sprintEndDate.getTime()) / (1e3 * 60 * 60 * 24));
      markdown += `- **Dias em rela\xE7\xE3o ao planejado**: ${diffDays} dias
`;
      markdown += `- **Status**: ${this.getDateStatus(mostLikelyDate.date, sprintEndDate)}

`;
      markdown += `### \u{1F4CA} M\xE9tricas Cr\xEDticas

`;
      markdown += `| M\xE9trica | Valor | Status |
`;
      markdown += `|---------|--------|--------|
`;
      const velocidadeNecessaria = metrics.remainingTasks / metrics.remainingDays;
      const velocidadeStatus = metrics.avgVelocity >= velocidadeNecessaria ? "\u2705" : "\u274C";
      markdown += `| Velocidade Atual | ${metrics.avgVelocity.toFixed(1)} tarefas/dia | ${velocidadeStatus} |
`;
      markdown += `| Velocidade Necess\xE1ria | ${velocidadeNecessaria.toFixed(1)} tarefas/dia | - |
`;
      markdown += `| Dias Restantes | ${metrics.remainingDays} dias | - |
`;
      markdown += `| Tarefas Restantes | ${metrics.remainingTasks} tarefas | - |

`;
      markdown += `### \u{1F4C5} Previs\xF5es de Data de Conclus\xE3o

`;
      markdown += `| Data | Probabilidade | Status | Observa\xE7\xE3o |
`;
      markdown += `|------|---------------|---------|------------|
`;
      completionDates.forEach((result) => {
        const diffDays2 = Math.round((result.date.getTime() - sprintEndDate.getTime()) / (1e3 * 60 * 60 * 24));
        let observation = "";
        if (result.probability === Math.max(...completionDates.map((d) => d.probability))) {
          observation = "\u{1F4CD} Data mais prov\xE1vel";
        } else if (diffDays2 <= 0) {
          observation = "\u{1F3AF} Dentro da sprint";
        }
        markdown += `| ${this.formatDate(result.date)} | ${result.probability.toFixed(1)}% | ${this.getDateStatus(result.date, sprintEndDate)} | ${observation} |
`;
      });
      markdown += `
`;
      markdown += `### \u{1F4CB} Status das Tarefas

`;
      const tasksByStatus = {
        "Conclu\xEDdo": (_b = this.data.sprintItems) == null ? void 0 : _b.filter(
          (t) => t.status === "DONE" || t.status === "Conclu\xEDdo"
        ).length,
        "Em Andamento": (_c = this.data.sprintItems) == null ? void 0 : _c.filter(
          (t) => t.status === "DOING" || t.status === "IN_PROGRESS" || t.status === "Em Andamento"
        ).length,
        "A Fazer": (_d = this.data.sprintItems) == null ? void 0 : _d.filter(
          (t) => t.status === "TODO" || t.status === "A Fazer"
        ).length
      };
      markdown += `| Status | Quantidade | Porcentagem |
`;
      markdown += `|--------|------------|-------------|
`;
      Object.entries(tasksByStatus).forEach(([status, count]) => {
        const percentage = ((count || 0) / metrics.totalTasks * 100).toFixed(1);
        markdown += `| ${status} | ${count || 0} | ${percentage}% |
`;
      });
      markdown += `
`;
      markdown += `## \u{1F4A1} Recomenda\xE7\xF5es

`;
      if (onTimeProb >= 85) {
        markdown += `1. \u2705 Mantenha o ritmo atual de ${metrics.avgVelocity.toFixed(1)} tarefas/dia
`;
        markdown += `2. \u2705 Continue monitorando impedimentos
`;
        markdown += `3. \u2705 Prepare-se para a pr\xF3xima sprint
`;
      } else if (onTimeProb >= 50) {
        markdown += `1. \u26A0\uFE0F Aumente a velocidade para ${velocidadeNecessaria.toFixed(1)} tarefas/dia
`;
        markdown += `2. \u26A0\uFE0F Priorize as tarefas cr\xEDticas
`;
        markdown += `3. \u26A0\uFE0F Remova impedimentos imediatamente
`;
      } else {
        markdown += `1. \u274C Realize reuni\xE3o emergencial
`;
        markdown += `2. \u274C Reavalie o escopo da sprint
`;
        markdown += `3. \u274C Considere remover tarefas
`;
      }
      markdown += `
`;
      markdown += `## \u2139\uFE0F Informa\xE7\xF5es da Sprint

`;
      markdown += `- **Sprint**: ${this.data.name}
`;
      markdown += `- **In\xEDcio**: ${this.formatDate(this.parseBrazilianDate(this.data.startDate))}
`;
      markdown += `- **T\xE9rmino Planejado**: ${this.formatDate(sprintEndDate)}
`;
      markdown += `- **Total de Tarefas**: ${metrics.totalTasks}
`;
      markdown += `- **Simula\xE7\xF5es Realizadas**: ${this.simulations.toLocaleString()}

`;
      markdown += `---
*Relat\xF3rio gerado em ${(/* @__PURE__ */ new Date()).toLocaleString("pt-BR")}*`;
      return markdown;
    } catch (error) {
      console.error("Erro ao gerar relat\xF3rio:", error);
      return `# \u274C Erro ao Gerar Relat\xF3rio

Ocorreu um erro ao gerar o relat\xF3rio: ${error instanceof Error ? error.message : "Erro desconhecido"}

Por favor, verifique os dados da sprint e tente novamente.`;
    }
  }
};

// src/documentation/service/markdown/chart/sprint/ProjectDependencyAnalyzer.ts
var ProjectDependencyAnalyzer = class {
  allIssues;
  sprintItems;
  graph;
  reversedGraph;
  issueStatus;
  constructor(sprint) {
    this.validateInputs(sprint);
    this.allIssues = /* @__PURE__ */ new Map();
    this.sprintItems = /* @__PURE__ */ new Map();
    this.graph = /* @__PURE__ */ new Map();
    this.reversedGraph = /* @__PURE__ */ new Map();
    this.issueStatus = /* @__PURE__ */ new Map();
    this.initializeFromSprint(sprint);
  }
  validateInputs(sprint) {
    if (!sprint.sprintItems) {
      throw new Error("Sprint n\xE3o cont\xE9m array de items");
    }
    sprint.sprintItems.forEach((item, index) => {
      if (!item.issue || !item.issue.id) {
        throw new Error(`Item do sprint na posi\xE7\xE3o ${index} n\xE3o tem issue ou ID v\xE1lido`);
      }
      if (!item.assignee || !item.assignee.name) {
        throw new Error(`Issue ${item.issue.id} n\xE3o tem respons\xE1vel definido`);
      }
    });
  }
  initializeFromSprint(sprint) {
    sprint.sprintItems.forEach((item) => {
      const issue = item.issue;
      this.allIssues.set(issue.id, issue);
      this.sprintItems.set(issue.id, item);
      this.graph.set(issue.id, /* @__PURE__ */ new Set());
      this.reversedGraph.set(issue.id, /* @__PURE__ */ new Set());
      this.issueStatus.set(issue.id, {
        inSprint: true,
        status: item.status || "TODO",
        assignee: item.assignee,
        implemented: item.status === "DONE"
      });
    });
    sprint.sprintItems.forEach((item) => {
      if (item.issue.depends && Array.isArray(item.issue.depends)) {
        item.issue.depends.forEach((dep) => {
          var _a, _b;
          if (dep && dep.id) {
            if (!this.allIssues.has(dep.id)) {
              this.allIssues.set(dep.id, dep);
              this.graph.set(dep.id, /* @__PURE__ */ new Set());
              this.reversedGraph.set(dep.id, /* @__PURE__ */ new Set());
              this.issueStatus.set(dep.id, {
                inSprint: false,
                status: dep.status || "EXTERNAL",
                implemented: false
              });
            }
            (_a = this.graph.get(item.issue.id)) == null ? void 0 : _a.add(dep.id);
            (_b = this.reversedGraph.get(dep.id)) == null ? void 0 : _b.add(item.issue.id);
          }
        });
      }
    });
  }
  findCycles() {
    const cycles = [];
    const visited = /* @__PURE__ */ new Set();
    const recursionStack = /* @__PURE__ */ new Set();
    const dfs = (nodeId, path6 = []) => {
      visited.add(nodeId);
      recursionStack.add(nodeId);
      path6.push(nodeId);
      const dependencies = this.graph.get(nodeId) || /* @__PURE__ */ new Set();
      for (const depId of dependencies) {
        if (!visited.has(depId)) {
          dfs(depId, [...path6]);
        } else if (recursionStack.has(depId)) {
          const cycleStartIndex = path6.indexOf(depId);
          cycles.push(path6.slice(cycleStartIndex));
        }
      }
      recursionStack.delete(nodeId);
    };
    this.sprintItems.forEach((_, id) => {
      if (!visited.has(id)) {
        dfs(id);
      }
    });
    return cycles;
  }
  generateMermaidDiagram() {
    let diagram = "graph BT\n";
    diagram += "    classDef sprint fill:#a8e6cf,stroke:#333,stroke-width:2px;\n";
    diagram += "    classDef done fill:#98fb98,stroke:#333,stroke-width:2px;\n";
    diagram += "    classDef external fill:#ffd3b6,stroke:#333,stroke-width:1px;\n";
    const externalDeps = /* @__PURE__ */ new Set();
    this.sprintItems.forEach((item) => {
      if (item.issue.depends && Array.isArray(item.issue.depends)) {
        item.issue.depends.forEach((dep) => {
          if (dep && dep.id && !this.sprintItems.has(dep.id)) {
            externalDeps.add(dep.id);
          }
        });
      }
    });
    externalDeps.forEach((id) => {
      const label = `${id}["\u{1F50D} ${id}<br>\u26A0\uFE0F Depend\xEAncia Externa"]`;
      diagram += `    ${label}:::external
`;
    });
    const issues = this.getTopologicalSort();
    issues.forEach((id) => {
      var _a;
      const item = this.sprintItems.get(id);
      const status = this.issueStatus.get(id);
      const nodeClass = status.implemented ? "done" : "sprint";
      const label = `${id}["\u{1F50D} Identificador: ${id}<br>\u{1F4DD} Tarefa: ${item.issue.title || "Sem t\xEDtulo"}<br>\u{1F4CA} Estado: ${status.status}<br>\u{1F464} Respons\xE1vel: ${((_a = status.assignee) == null ? void 0 : _a.name) || "N/A"}"]`;
      diagram += `    ${label}:::${nodeClass}
`;
    });
    this.sprintItems.forEach((item) => {
      if (item.issue.depends && Array.isArray(item.issue.depends)) {
        item.issue.depends.forEach((dep) => {
          if (dep && dep.id) {
            const style = this.sprintItems.has(dep.id) ? "-->" : "-.->";
            diagram += `    ${item.issue.id} ${style} ${dep.id}
`;
          }
        });
      }
    });
    return diagram;
  }
  getTopologicalSort() {
    const result = [];
    const independentTasks = [];
    const dependentTasks = [];
    const processed = /* @__PURE__ */ new Set();
    const inDegree = /* @__PURE__ */ new Map();
    this.sprintItems.forEach((_, id) => {
      inDegree.set(id, 0);
    });
    this.sprintItems.forEach((item) => {
      if (item.issue.depends && Array.isArray(item.issue.depends)) {
        item.issue.depends.forEach((dep) => {
          if (dep && dep.id && this.sprintItems.has(dep.id)) {
            inDegree.set(dep.id, (inDegree.get(dep.id) || 0) + 1);
          }
        });
      }
    });
    this.sprintItems.forEach((item, id) => {
      if (!item.issue.depends || !Array.isArray(item.issue.depends) || item.issue.depends.length === 0) {
        independentTasks.push(id);
        processed.add(id);
      } else {
        const hasOnlyExternalDeps = item.issue.depends.every(
          (dep) => !dep.id || !this.sprintItems.has(dep.id)
        );
        if (hasOnlyExternalDeps) {
          independentTasks.push(id);
          processed.add(id);
        } else {
          dependentTasks.push(id);
        }
      }
    });
    const queue = dependentTasks.filter((id) => (inDegree.get(id) || 0) === 0);
    const orderedDependentTasks = [];
    while (queue.length > 0) {
      const current = queue.shift();
      if (!processed.has(current)) {
        orderedDependentTasks.push(current);
        processed.add(current);
        const dependencies = this.graph.get(current) || /* @__PURE__ */ new Set();
        dependencies.forEach((dep) => {
          if (this.sprintItems.has(dep)) {
            const newDegree = (inDegree.get(dep) || 0) - 1;
            inDegree.set(dep, newDegree);
            if (newDegree === 0 && !processed.has(dep)) {
              queue.push(dep);
            }
          }
        });
      }
    }
    result.push(...independentTasks, ...orderedDependentTasks);
    return result;
  }
  generateAnalysis() {
    if (this.sprintItems.size === 0) {
      return "# An\xE1lise de Depend\xEAncias do Sprint\n\nNenhuma issue encontrada no sprint.";
    }
    let markdown = "# An\xE1lise de Depend\xEAncias do Sprint\n\n";
    markdown += `An\xE1lise gerada em: ${(/* @__PURE__ */ new Date()).toLocaleString("pt-BR")}

`;
    markdown += "## \u{1F50D} Grafo de Depend\xEAncias\n\n";
    markdown += "```mermaid\n";
    markdown += this.generateMermaidDiagram();
    markdown += "```\n\n";
    markdown += "**Legenda:**\n";
    markdown += "- \u{1F7E2} Verde Claro: Issues no sprint\n";
    markdown += "- \u{1F7E2} Verde Escuro: Issues conclu\xEDdas\n";
    markdown += "- \u{1F7E1} Laranja: Depend\xEAncias externas ao sprint\n";
    markdown += "- \u27A1\uFE0F Linha s\xF3lida: Depend\xEAncia no sprint\n";
    markdown += "- \u27A1\uFE0F Linha pontilhada: Depend\xEAncia externa\n\n";
    const cycles = this.findCycles();
    if (cycles.length > 0) {
      markdown += "## \u26A0\uFE0F Ciclos de Depend\xEAncia Detectados\n\n";
      cycles.forEach((cycle, index) => {
        markdown += `### Ciclo ${index + 1}
`;
        markdown += cycle.map((id) => {
          const issue = this.allIssues.get(id);
          return `${id} (${issue.title || "Sem t\xEDtulo"})`;
        }).join(" \u2192 ") + ` \u2192 ${cycle[0]}

`;
      });
    }
    markdown += "## \u{1F4CB} Sugest\xE3o de Execu\xE7\xE3o das Issues\n\n";
    markdown += "| # | Issue | T\xEDtulo | Status | Respons\xE1vel | Depend\xEAncias |\n";
    markdown += "|---|-------|--------|--------|-------------|---------------|\n";
    const orderedIssues = this.getTopologicalSort();
    orderedIssues.forEach((id, index) => {
      const item = this.sprintItems.get(id);
      const allDeps = /* @__PURE__ */ new Set();
      if (item.issue.depends && Array.isArray(item.issue.depends)) {
        item.issue.depends.forEach((dep) => {
          if (dep && dep.id) allDeps.add(dep.id);
        });
      }
      const dependenciesStr = Array.from(allDeps).map((depId) => {
        if (this.sprintItems.has(depId)) {
          const depStatus = this.issueStatus.get(depId);
          return `${depId}${depStatus.implemented ? "\u2705" : ""}`;
        }
        return `${depId}\u26A0\uFE0F`;
      }).join(", ") || "\u{1F193}";
      markdown += `| ${index + 1} | ${id} | ${item.issue.title || "N/A"} | ${item.status || "TODO"} | ${item.assignee.name} | ${dependenciesStr} |
`;
    });
    markdown += "\n**Legenda das Depend\xEAncias:**\n";
    markdown += "- \u{1F193} Sem depend\xEAncias\n";
    markdown += "- \u2705 Issue conclu\xEDda\n";
    markdown += "- \u26A0\uFE0F Depend\xEAncia externa ao sprint\n";
    return markdown;
  }
};

// src/documentation/service/markdown/MarkdownTimeBoxService.ts
var MarkdownTimeBoxService = class {
  target_folder;
  TIMEBOX_PATH;
  TIMEBOX_CHARTS_PATH;
  jsonFile;
  DB_PATH;
  constructor(target_folder, db_path) {
    this.target_folder = target_folder;
    this.TIMEBOX_PATH = createPath(this.target_folder, "sprints");
    this.TIMEBOX_CHARTS_PATH = createPath(this.TIMEBOX_PATH, "charts");
    this.jsonFile = "timebox.json";
    this.DB_PATH = db_path;
  }
  async createCategory() {
    return `
        {
            "label": " \u{1F680} Sprints",
            "position": 4,
            "link": {
                "type": "generated-index",
                "description": "Documentos sobre os sprints."
            }
            }
        `;
  }
  async createCategoryIndex() {
    return `
      {
        "label": "Gest\xE3o",
        "position": 1,
        "link": {
            "type": "generated-index",
            "description": "Documentos relativos ao planejamento."
        }
        }
        `;
  }
  async create() {
    const timeBoxes = await this.retrive(this.jsonFile);
    const filePathCategory = path4.join(this.TIMEBOX_PATH, "_category_.json");
    const filePathCategoryxxx = path4.join(this.target_folder, "_category_.json");
    fs7.writeFileSync(filePathCategory, await this.createCategory());
    fs7.writeFileSync(filePathCategoryxxx, await this.createCategoryIndex());
    timeBoxes.forEach((timebox) => {
      const fileName = `/${timebox.id}.md`;
      const filePath = path4.join(this.TIMEBOX_PATH, fileName);
      const exist = this.fileContainsName(this.TIMEBOX_PATH, fileName);
      let generatorx = new CumulativeFlowDiagram(timebox, this.TIMEBOX_CHARTS_PATH + `/cfd-${timebox.id}.svg`);
      if (!exist) {
        fs7.writeFileSync(filePath, this.createTimeBoxExport(timebox));
        generatorx.generate();
      }
      if (exist && timebox.status != "CLOSED") {
        fs7.writeFileSync(filePath, this.createTimeBoxExport(timebox));
        generatorx.generate();
      }
    });
  }
  fileContainsName(directory, partialName) {
    try {
      const files = readdirSync(directory);
      return files.some((file) => file.includes(partialName));
    } catch (error) {
      console.error(`Erro ao acessar o diret\xF3rio: ${error}`);
      return false;
    }
  }
  createTimeBoxExport(timeBox) {
    var _a;
    let monteCarloAnalysis = "";
    if (timeBox.status == "IN_PROGRESS") {
      const monteCarlo = new SprintMonteCarlo(timeBox, 1e4);
      monteCarloAnalysis = monteCarlo.generateMarkdownReport();
    }
    const analyzer = new ProjectDependencyAnalyzer(timeBox);
    const dependencyAnalysis = analyzer.generateAnalysis();
    return `
        
        # ${timeBox.name.toLocaleUpperCase()}
        ${timeBox.description}

        ## Dados do Sprint
        * **Goal**:  ${timeBox.description}
        * **Data In\xEDcio**: ${timeBox.startDate}
        * **Data Fim**: ${timeBox.endDate}
        * **Status**: ${timeBox.status}
        ## Sprint Backlog

        |ID |Nome |Respos\xE1vel |Data de Inic\xEDo | Data Planejada | Status|
        |:----    |:----|:--------  |:-------:       | :----------:  | :---: |
        ${(_a = timeBox.sprintItems) == null ? void 0 : _a.map((assignee) => {
      var _a2;
      return `|${assignee.issue.id.toLocaleLowerCase()}|${assignee.issue.title ?? "-"}|${assignee.assignee.name}|${assignee.startDate ?? ""}|${assignee.dueDate ?? ""}|${(_a2 = assignee.status) == null ? void 0 : _a2.toLocaleUpperCase()}|`;
    }).join("\n")}
      
        ${dependencyAnalysis}
        
       
        ## Cumulative Flow
        ![ Cumulative Flow](./charts/cfd-${timeBox.id}.svg)
        
        ${monteCarloAnalysis}
        `;
  }
  async retrive(database) {
    const ISSUEPATH = path4.join(this.DB_PATH, database);
    const adapter = new JSONFileSync2(ISSUEPATH);
    const defaultData = { data: [] };
    const db = new LowSync2(adapter, defaultData);
    await db.read();
    return db.data.data.sort((a, b) => {
      return Number(a.id) - Number(b.id);
    });
  }
};

// src/documentation/service/markdown/MarkdownRoadmapService.ts
import * as path5 from "path";
import * as fs8 from "fs";
import { LowSync as LowSync3 } from "lowdb";
import { JSONFileSync as JSONFileSync3 } from "lowdb/node";

// src/documentation/service/markdown/report/RoadmapReportGenerator.ts
var RoadmapReportGenerator = class {
  roadmaps;
  constructor(roadmaps) {
    this.roadmaps = roadmaps;
  }
  formatDate(dateStr) {
    if (!dateStr) return "N/A";
    try {
      if (dateStr.includes("/")) {
        const [day2, month2, year2] = dateStr.split("/");
        const date2 = /* @__PURE__ */ new Date(`${year2}-${month2}-${day2}`);
        if (isNaN(date2.getTime())) return "N/A";
        return dateStr;
      }
      const date = new Date(dateStr);
      if (isNaN(date.getTime())) return "N/A";
      const day = date.getDate().toString().padStart(2, "0");
      const month = (date.getMonth() + 1).toString().padStart(2, "0");
      const year = date.getFullYear();
      return `${day}/${month}/${year}`;
    } catch (error) {
      console.error("Erro ao formatar data:", error);
      return "N/A";
    }
  }
  getStatusEmoji(status) {
    const statusEmojis = {
      PLANNED: "\u{1F4CB}",
      IN_PROGRESS: "\u{1F3C3}",
      COMPLETED: "\u2705",
      DELAYED: "\u26A0\uFE0F",
      IN_DEVELOPMENT: "\u{1F3D7}\uFE0F",
      TESTING: "\u{1F9EA}",
      RELEASED: "\u2728"
    };
    return statusEmojis[status] || "\u2753";
  }
  generateMilestonesSection(roadmap) {
    var _a;
    if (!((_a = roadmap.milestones) == null ? void 0 : _a.length)) return "";
    const milestonesContent = roadmap.milestones.map((milestone) => {
      var _a2, _b;
      return `
### ${this.getStatusEmoji(milestone.status || "PLANNED")} ${milestone.name} (${milestone.status})
- **In\xEDcio**: ${this.formatDate(milestone.startDate)}
- **Conclus\xE3o${milestone.status !== "COMPLETED" ? " Prevista" : ""}**: ${this.formatDate(milestone.dueDate)}
- **Descri\xE7\xE3o**: ${milestone.description}
${((_a2 = milestone.releases) == null ? void 0 : _a2.length) ? `- **Releases Associadas**: ${milestone.releases.map((r) => r.version).join(", ")}` : "- **Releases**: Nenhuma"}
${((_b = milestone.dependencies) == null ? void 0 : _b.length) ? `- **Depend\xEAncias**: ${milestone.dependencies.map((d) => d.name).join(", ")}` : "- **Depend\xEAncias**: Nenhuma"}
      
    ${this.generateReleasesTable(milestone.releases)}
      `;
    }).join("\n");
    return `
## \u{1F3AF} Milestones

${milestonesContent}
`;
  }
  generateReleasesTable(releases) {
    if (!(releases == null ? void 0 : releases.length)) return "";
    return `
#### Releases
| Vers\xE3o | Nome | Status | Data Prevista | Data Release |
|--------|------|--------|---------------|--------------|
${releases.map(
      (release) => `| ${release.version} | ${release.name} | ${this.getStatusEmoji(release.status || "PLANNED")} ${release.status} | ${this.formatDate(release.dueDate)} | ${this.formatDate(release.releasedDate || "")} |`
    ).join("\n")}

${this.generateIssuesTable(releases)}
`;
  }
  generateIssuesTable(releases) {
    if (!(releases == null ? void 0 : releases.length)) return "";
    const allIssues = releases.flatMap((release) => release.issues || []);
    if (!allIssues.length) return "";
    return `
#### Issues
| Key | Tipo | T\xEDtulo | Status | Labels |
|-----|------|--------|--------|--------|
${allIssues.map(
      (issue) => {
        var _a;
        return `| ${issue.id || "N/A"} | ${issue.type} | ${issue.title || "N/A"} | ${issue.status || "N/A"} | ${((_a = issue.labels) == null ? void 0 : _a.join(", ")) || "N/A"} |`;
      }
    ).join("\n")}
`;
  }
  generateProgressOverview(roadmap) {
    const milestones = roadmap.milestones || [];
    const statusCount = {
      total: milestones.length,
      completed: milestones.filter((m) => m.status === "COMPLETED").length,
      inProgress: milestones.filter((m) => m.status === "IN_PROGRESS").length,
      planned: milestones.filter((m) => m.status === "PLANNED").length,
      delayed: milestones.filter((m) => m.status === "DELAYED").length
    };
    return `
## \u{1F4CA} Vis\xE3o Geral do Progresso

Status atual do roadmap:
- Total de Milestones: ${statusCount.total}
- Conclu\xEDdos: ${statusCount.completed}
- Em Progresso: ${statusCount.inProgress}
- Planejados: ${statusCount.planned}
- Atrasados: ${statusCount.delayed}

Progresso: ${statusCount.total ? Math.round(statusCount.completed / statusCount.total * 100) : 0}%
`;
  }
  generateTimeline(roadmap) {
    var _a;
    if (!((_a = roadmap.milestones) == null ? void 0 : _a.length)) return "";
    const timelineItems = roadmap.milestones.flatMap((milestone) => {
      var _a2;
      return [
        {
          date: milestone.startDate,
          type: "Milestone Start",
          name: milestone.name,
          status: milestone.status
        },
        {
          date: milestone.dueDate,
          type: "Milestone Due",
          name: milestone.name,
          status: milestone.status
        },
        ...((_a2 = milestone.releases) == null ? void 0 : _a2.map((release) => ({
          date: release.dueDate,
          type: "Release",
          name: `${release.version} - ${release.name}`,
          status: release.status
        }))) || []
      ];
    }).sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());
    return `
## \u{1F4C5} Timeline

${timelineItems.map(
      (item) => `- ${this.formatDate(item.date)} - ${this.getStatusEmoji(item.status || "PLANNED")} **${item.type}**: ${item.name}`
    ).join("\n")}
`;
  }
  generateReport() {
    let report = "# \u{1F3AF} Roadmaps\n\n";
    this.roadmaps.forEach((roadmap) => {
      report += `# ${roadmap.name || "Roadmap sem nome"}

`;
      report += roadmap.description ? `${roadmap.description}

` : "";
      report += this.generateProgressOverview(roadmap);
      report += this.generateMilestonesSection(roadmap);
      report += this.generateTimeline(roadmap);
    });
    return report;
  }
  generateSingleRoadmapReport(roadmapId) {
    const roadmap = this.roadmaps.find((r) => r.id === roadmapId);
    if (!roadmap) return null;
    return `# ${roadmap.name || "Relat\xF3rio de Progresso do Roadmap"}

${roadmap.description || ""}

${this.generateProgressOverview(roadmap)}
${this.generateMilestonesSection(roadmap)}
${this.generateTimeline(roadmap)}
`;
  }
};

// src/documentation/service/markdown/MarkdownRoadmapService.ts
var MardownRoadmapService = class {
  target_folder;
  jsonFile;
  DB_PATH;
  constructor(target_folder, db_path) {
    this.target_folder = target_folder;
    this.jsonFile = "roadmap.json";
    this.DB_PATH = db_path;
  }
  async create() {
    let roadmap = await this.retrive(this.jsonFile);
    const generator = new RoadmapReportGenerator(roadmap);
    fs8.writeFileSync(path5.join(this.target_folder, `/03_roadmap.md`), generator.generateReport());
  }
  async retrive(database) {
    const ISSUEPATH = path5.join(this.DB_PATH, database);
    const adapter = new JSONFileSync3(ISSUEPATH);
    const defaultData = { data: [] };
    const db = new LowSync3(adapter, defaultData);
    await db.read();
    return db.data.data.sort((a, b) => {
      return Number(a.id) - Number(b.id);
    });
  }
};

// src/documentation/service/markdown/MarkdownService.ts
var MarkdownService = class {
  target_folder;
  DB_PATH;
  markdownBacklogService;
  markdownTimeBoxService;
  markdownRoadmapService;
  constructor(target_folder) {
    this.target_folder = target_folder;
    this.DB_PATH = createPath(this.target_folder, "db");
    fs9.mkdirSync(this.target_folder, { recursive: true });
    this.markdownBacklogService = new MarkdownBacklogService(this.target_folder, this.DB_PATH);
    this.markdownTimeBoxService = new MarkdownTimeBoxService(this.target_folder, this.DB_PATH);
    this.markdownRoadmapService = new MardownRoadmapService(this.target_folder, this.DB_PATH);
  }
  createManagementDocumenation() {
    this.markdownTimeBoxService.create();
    this.markdownBacklogService.create();
    this.markdownRoadmapService.create();
  }
};

// src/index.ts
var ReportManager = class {
  createReport(dbPath) {
    const markdownService = new MarkdownService(dbPath);
    markdownService.createManagementDocumenation();
  }
};
export {
  ReportManager
};
